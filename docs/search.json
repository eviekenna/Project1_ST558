[
  {
    "objectID": "proj_1.html",
    "href": "proj_1.html",
    "title": "Project 1",
    "section": "",
    "text": "We implemented four main pieces: (1) a response helper, (2) a single-year query function, (3) a multi-year wrapper, and (4) categorical variable labeling.\n\nHelper- we followed our class notes: build a URL, call httr::GET(), convert the first row of the JSON to headers, then coerce types. We parameterized it with numeric_vars and categorical_vars so the same function can clean different requests without repeating code.\nSingle-year function (query_census) – This enforces the project requirements:\n\nValidates the year (2010–2022).\nRestricts variables to the allowed sets and always includes PWGTP, while requiring at least one extra numeric and one categorical.\nImplements geography. ST (state) can be filtered server-side; REGION and DIVISION are returned as columns and then filtered client-side.\nConverts JWAP and JWDP commute time codes into numeric values (minutes after midnight) by mapping each code to the midpoint of its 5-minute bin.\nApplies label_categorical_vars() so categorical variables (e.g., SEX, REGION, SCHL, JWTRNS) are returned as factors with human-readable labels.\nAttaches a YEAR column and gives the tibble an extra \"census\" class so custom methods can recognize it.\n\nMulti-year function (query_census_multi) – Calls query_census() once per year, row-binds the results, and skips unavailable endpoints (e.g., ACS1 PUMS 2020) with a message. This allows easy analysis across multiple years.\nCategorical labeling (label_categorical_vars) – A helper that maps Census codes to human-readable factor levels across variables like FER, HHL, HISPEED, JWTRNS, SCH, SCHL, SEX, REGION, DIVISION, and ST. This makes the returned tibbles easier to read and analyze while still preserving the \"census\" class for custom methods.\n\n\n\n\nSetup — load packages\n\n\nShow/Hide Code\n# Packages\nlibrary(dplyr)\nlibrary(jsonlite)\nlibrary(tibble)\nlibrary(httr)\n\n\nFirst we created a helper function.\nThe helper function handles the raw API response:\n- Builds a tibble by converting the first row of JSON into headers.\n- Coerces numeric variables when requested.\n- Leaves categorical variables as-is for labeling later.\n\n\nShow/Hide Code\nhelper &lt;- function(resp,\n                   numeric_vars = NULL,\n                   categorical_vars = NULL) {\n  parsed &lt;- fromJSON(rawToChar(resp$content))\n  \n  colnames(parsed) &lt;- parsed[1, ]     \n  dat &lt;- as_tibble(parsed[-1, ]) \n  \n  # convert numeric vars\n  if (!is.null(numeric_vars)) {\n    for (v in numeric_vars) if (v %in% names(dat)) {\n      dat[[v]] &lt;- suppressWarnings(as.numeric(dat[[v]]))\n    }\n  }\n  \n  # convert categorical vars\n  if (!is.null(categorical_vars)) {\n    for (v in categorical_vars) if (v %in% names(dat)) {\n      dat[[v]] &lt;- as.factor(dat[[v]])\n    }\n  }\n  \n  return(dat)\n}\n\n\nWe then added a label_categorical_vars() helper that replaces raw Census codes with descriptive factor labels. For example, SEX is now \"Male\"/\"Female\" instead of \"1\"/\"2\", REGION becomes \"Northeast\", \"Midwest\", \"South\", \"West\", and JWTRNS shows the actual transportation modes instead of numeric codes.\nThis step makes the returned tibble far easier to interpret and analyze, while still keeping the \"census\" class so that custom methods (summary.census, plot.census) can use these labeled factors directly.\n\n\nShow/Hide Code\nlabel_categorical_vars &lt;- function(dat) {\n \n  # FER - Gave birth to child within the past 12 months\n  if (\"FER\" %in% names(dat)) {\n    dat$FER &lt;- factor(dat$FER,\n                      levels = c(\"1\", \"2\"),\n                      labels = c(\"Yes\", \"No\"))\n  }\n \n  # HHL - Household language\n  if (\"HHL\" %in% names(dat)) {\n    dat$HHL &lt;- factor(dat$HHL,\n                      levels = c(\"1\", \"2\", \"3\", \"4\", \"5\"),\n                      labels = c(\"English only\",\n                                \"Spanish\",\n                                \"Other Indo-European\",\n                                \"Asian/Pacific Island\",\n                                \"Other\"))\n  }\n \n  # HISPEED - Broadband Internet service\n  if (\"HISPEED\" %in% names(dat)) {\n    dat$HISPEED &lt;- factor(dat$HISPEED,\n                          levels = c(\"1\", \"2\"),\n                          labels = c(\"Yes\", \"No\"))\n  }\n \n  # JWTRNS - Means of transportation to work\n  if (\"JWTRNS\" %in% names(dat)) {\n    dat$JWTRNS &lt;- factor(dat$JWTRNS,\n                         levels = c(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\",\n                                   \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"),\n                         labels = c(\"Car/truck/van\",\n                                   \"Bus\",\n                                   \"Subway/rail\",\n                                   \"Train\",\n                                   \"Light rail\",\n                                   \"Ferry\",\n                                   \"Taxi\",\n                                   \"Motorcycle\",\n                                   \"Bicycle\",\n                                   \"Walked\",\n                                   \"Work from home\",\n                                   \"Other\"))\n  }\n \n  # SCH - School enrollment\n  if (\"SCH\" %in% names(dat)) {\n    dat$SCH &lt;- factor(dat$SCH,\n                      levels = c(\"1\", \"2\", \"3\"),\n                      labels = c(\"Not in school\",\n                                \"Public school\",\n                                \"Private school\"))\n  }\n \n  # SCHL - Educational attainment\n  if (\"SCHL\" %in% names(dat)) {\n    dat$SCHL &lt;- factor(dat$SCHL,\n                       levels = c(\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\",\n                                 \"09\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\",\n                                 \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\"),\n                       labels = c(\"No schooling\",\n                                 \"Preschool\",\n                                 \"Kindergarten\",\n                                 \"Grade 1\", \"Grade 2\", \"Grade 3\", \"Grade 4\",\n                                 \"Grade 5\", \"Grade 6\", \"Grade 7\", \"Grade 8\",\n                                 \"Grade 9\", \"Grade 10\", \"Grade 11\",\n                                 \"Grade 12 - no diploma\",\n                                 \"High school diploma\",\n                                 \"GED\",\n                                 \"Some college &lt; 1 year\",\n                                 \"Some college ≥ 1 year\",\n                                 \"Associate's\",\n                                 \"Bachelor's\",\n                                 \"Master's\",\n                                 \"Professional degree\",\n                                 \"Doctorate\"))\n  }\n \n  # SEX\n  if (\"SEX\" %in% names(dat)) {\n    dat$SEX &lt;- factor(dat$SEX,\n                      levels = c(\"1\", \"2\"),\n                      labels = c(\"Male\", \"Female\"))\n  }\n \n  # REGION - Census regions\n  if (\"REGION\" %in% names(dat)) {\n    dat$REGION &lt;- factor(dat$REGION,\n                         levels = c(\"1\", \"2\", \"3\", \"4\"),\n                         labels = c(\"Northeast\", \"Midwest\", \"South\", \"West\"))\n  }\n \n  # DIVISION - Census divisions\n  if (\"DIVISION\" %in% names(dat)) {\n    dat$DIVISION &lt;- factor(dat$DIVISION,\n                           levels = c(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"),\n                           labels = c(\"New England\",\n                                     \"Middle Atlantic\",\n                                     \"East North Central\",\n                                     \"West North Central\",\n                                     \"South Atlantic\",\n                                     \"East South Central\",\n                                     \"West South Central\",\n                                     \"Mountain\",\n                                     \"Pacific\"))\n  }\n \n  # ST - State FIPS codes\n  if (\"ST\" %in% names(dat)) {\n    dat$ST &lt;- factor(dat$ST,\n                     levels = c(\"01\", \"02\", \"04\", \"05\", \"06\", \"08\", \"09\", \"10\", \"11\", \"12\",\n                               \"13\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\",\n                               \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\", \"32\", \"33\",\n                               \"34\", \"35\", \"36\", \"37\", \"38\", \"39\", \"40\", \"41\", \"42\", \"44\",\n                               \"45\", \"46\", \"47\", \"48\", \"49\", \"50\", \"51\", \"53\", \"54\", \"55\",\n                               \"56\"),\n                     labels = c(\"Alabama\", \"Alaska\", \"Arizona\", \"Arkansas\", \"California\",\n                               \"Colorado\", \"Connecticut\", \"Delaware\", \"District of Columbia\",\n                               \"Florida\", \"Georgia\", \"Hawaii\", \"Idaho\", \"Illinois\", \"Indiana\",\n                               \"Iowa\", \"Kansas\", \"Kentucky\", \"Louisiana\", \"Maine\", \"Maryland\",\n                               \"Massachusetts\", \"Michigan\", \"Minnesota\", \"Mississippi\", \"Missouri\",\n                               \"Montana\", \"Nebraska\", \"Nevada\", \"New Hampshire\", \"New Jersey\",\n                               \"New Mexico\", \"New York\", \"North Carolina\", \"North Dakota\", \"Ohio\",\n                               \"Oklahoma\", \"Oregon\", \"Pennsylvania\", \"Rhode Island\", \"South Carolina\",\n                               \"South Dakota\", \"Tennessee\", \"Texas\", \"Utah\", \"Vermont\", \"Virginia\",\n                               \"Washington\", \"West Virginia\", \"Wisconsin\", \"Wyoming\"))\n  }\n \n  return(dat)\n}\n\n\n\n\nShow/Hide Code\n# sanity check — build a URL, GET it, look at the response\n# quick, proof-of-concept\nurl_demo &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums?get=AGEP,SEX,PWGTP\"\nresp_demo &lt;- GET(url_demo)\n\n# Demo of the helper on the demo response: shows the basic flow works\ndemo_tbl &lt;- helper(resp_demo, numeric_vars = c(\"AGEP\",\"PWGTP\"), categorical_vars = \"SEX\")\nglimpse(demo_tbl) \n\n\nRows: 3,373,378\nColumns: 3\n$ AGEP  &lt;dbl&gt; 17, 73, 22, 82, 19, 88, 80, 33, 44, 36, 17, 52, 72, 29, 20, 43, …\n$ SEX   &lt;fct&gt; 2, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2…\n$ PWGTP &lt;dbl&gt; 3, 42, 11, 32, 31, 32, 45, 37, 29, 55, 12, 41, 14, 3, 119, 91, 3…\n\n\nThen we created the main function of the project: the query_census function. This function wraps the entire workflow: it validates the year (only allowing 2010–2022), enforces the rule that PWGTP must always be included, checks that the requested variables are from the allowed sets, and handles geography. States can be filtered server-side with an ST parameter, while Regions and Divisions are requested in the data and then filtered client-side.\nWe also had to deal with commute time variables (JWAP and JWDP). These are stored as codes for 5-minute bins, so we wrote a converter that maps each code to the midpoint minutes after midnight. That way, we can analyze them as real numeric times. Finally, we applied the categorical labels and tagged the tibble with a custom \"census\" class so we can write methods for it later.\n\n\nShow/Hide Code\nquery_census &lt;- function(year = 2022,\n                         num_var = c(\"AGEP\",\"PWGTP\"),\n                         cat_var = \"SEX\",\n                         geo = c(\"All\",\"Region\",\"Division\",\"State\"),\n                         geo_values = NULL) {\n  library(httr); library(jsonlite); library(tibble); library(dplyr)\n\n  if (!is.numeric(year) || length(year) != 1 || year &lt; 2010 || year &gt; 2022)\n    stop(\"year must be a single number in 2010–2022\", call. = FALSE)\n\n  # always include PWGTP\n  if (!\"PWGTP\" %in% num_var) num_var &lt;- c(\"PWGTP\", num_var)\n\n  num_allowed &lt;- c(\"AGEP\",\"GASP\",\"GRPIP\",\"JWAP\",\"JWDP\",\"JWMNP\",\"PWGTP\")\n  cat_allowed &lt;- c(\"FER\",\"HHL\",\"HISPEED\",\"JWTRNS\",\"SCH\",\"SCHL\",\"SEX\")\n\n  num_var &lt;- toupper(num_var); cat_var &lt;- toupper(cat_var)\n  stopifnot(all(num_var %in% num_allowed), all(cat_var %in% cat_allowed))\n  if (length(setdiff(num_var,\"PWGTP\")) &lt; 1) stop(\"need ≥1 numeric besides PWGTP\")\n  if (length(cat_var) &lt; 1) stop(\"need ≥1 categorical\")\n\n  geo &lt;- match.arg(geo)\n  # only ST can be filtered server-side; REGION/DIVISION will be filtered client-side\n  geog_var &lt;- switch(geo,\n    \"All\"      = NULL,\n    \"State\"    = \"ST\",\n    \"Region\"   = \"REGION\",\n    \"Division\" = \"DIVISION\"\n  )\n\n  # ---- build URL: no REGION/DIVISION in query string ----\n  base &lt;- sprintf(\"https://api.census.gov/data/%d/acs/acs1/pums\", as.integer(year))\n  get_vars &lt;- paste(c(unique(num_var), unique(cat_var),\n                      # include REGION/DIVISION in the return set if the user asked for them\n                      if (geo %in% c(\"Region\",\"Division\")) geog_var),\n                    collapse = \",\")\n  qs &lt;- paste0(\"get=\", get_vars)\n\n  # only add ST filter to URL; others will be post-filtered\n  geo_part &lt;- \"\"\n  if (!is.null(geog_var) && geog_var == \"ST\" && length(geo_values)) {\n    geo_vals &lt;- paste0(\"ST=\", geo_values)\n    geo_part &lt;- paste0(\"&\", paste(geo_vals, collapse = \"&\"))\n  }\n\n  url &lt;- paste0(base, \"?\", qs, geo_part)\n\n  resp &lt;- GET(url)\n  if (resp$status_code != 200) stop(\"API request failed (\", resp$status_code, \"): \", url, call. = FALSE)\n\n  # use helper() to parse and type most vars; time vars handled below\n  time_vars &lt;- intersect(num_var, c(\"JWAP\",\"JWDP\"))\n  numeric_for_helper &lt;- setdiff(num_var, time_vars)\n  dat &lt;- helper(resp, numeric_vars = numeric_for_helper)  # Remove categorical_vars argument\n\n # time bins → midpoint minutes (for 5-minute bins)\njw_to_minutes &lt;- function(x) {\n  code &lt;- suppressWarnings(as.numeric(as.character(x)))\n  ok &lt;- !is.na(code) & code &gt;= 1 & code &lt;= 288\n  out &lt;- rep(NA_real_, length(x))\n  out[ok] &lt;- (code[ok] - 1) * 5 + 2.5  # Midpoint of each 5-minute bin\n  return(out)\n}\n  if (\"JWAP\" %in% names(dat)) dat$JWAP &lt;- jw_to_minutes(dat$JWAP)\n  if (\"JWDP\" %in% names(dat)) dat$JWDP &lt;- jw_to_minutes(dat$JWDP)\n\n \n\n  # client-side filter for Region/Division if requested\n  if (geo == \"Region\" && length(geo_values)) {\n    if (!\"REGION\" %in% names(dat)) stop(\"REGION not returned; add it to get=.\")\n    dat &lt;- dat %&gt;% filter(.data$REGION %in% as.character(geo_values))\n  }\n  if (geo == \"Division\" && length(geo_values)) {\n    if (!\"DIVISION\" %in% names(dat)) stop(\"DIVISION not returned; add it to get=.\")\n    dat &lt;- dat %&gt;% filter(.data$DIVISION %in% as.character(geo_values))\n  }\n dat &lt;- label_categorical_vars(dat)\n  dat$YEAR &lt;- as.integer(year)\n  class(dat) &lt;- c(\"census\", class(dat))\n  dat\n}\n\n\nLight tests (single year) — demonstrate each requirement is met:\n\n\nShow/Hide Code\n# simple default\nd1 &lt;- query_census()\n\n# region subset, with a time variable\nd2 &lt;- query_census(year = 2022,\n                   num_var = c(\"JWAP\",\"PWGTP\"),\n                   cat_var = c(\"SEX\",\"JWTRNS\"),\n                   geo = \"Region\", geo_values = c(1,3))\n\nglimpse(d2)\n\n\nRows: 1,871,742\nColumns: 6\n$ JWAP   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, 432.5, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ PWGTP  &lt;dbl&gt; 42, 31, 32, 45, 55, 41, 119, 24, 6, 25, 50, 80, 48, 59, 21, 145…\n$ SEX    &lt;fct&gt; Male, Female, Male, Male, Male, Male, Male, Male, Male, Male, M…\n$ JWTRNS &lt;fct&gt; NA, NA, NA, NA, NA, NA, Car/truck/van, NA, NA, Work from home, …\n$ REGION &lt;fct&gt; South, Northeast, South, South, South, South, South, Northeast,…\n$ YEAR   &lt;int&gt; 2022, 2022, 2022, 2022, 2022, 2022, 2022, 2022, 2022, 2022, 202…\n\n\n\n\nThis test calls our function where we add a time variable (JWAP) and a categorical (JWTRNS), filtering to two regions.\nThe output tibble contains JWAP converted to minutes, SEX labeled, and JWTRNS with descriptive categories.\nThe REGION column is present, and filtering reduces the dataset to the requested regions.\nThis shows that client-side filtering is working correctly.\n\nFinally, we wanted to study multiple years at once. To do this efficiently, we wrote query_census_multi(), which loops over a vector of years with lapply(). For each year, it calls query_census(). If a year fails (because the API endpoint doesn’t exist, like in 2020), it gets skipped with a message. All the successful results are then bound together into a single tibble with a YEAR column for comparison.\n\n\nShow/Hide Code\nquery_census_multi &lt;- function(years,\n                               num_var = c(\"AGEP\",\"PWGTP\"),\n                               cat_var = \"SEX\",\n                               geo = c(\"All\",\"Region\",\"Division\",\"State\"),\n                               geo_values = NULL) {\n  # Convert input years to integers\n  years &lt;- as.integer(years)\n  \n  # Ensure at least one year is provided\n  if (length(years) &lt; 1) stop(\"Provide at least one year.\", call. = FALSE)\n\n  # Loop over each year with lapply\n  pieces &lt;- lapply(years, function(y) {\n    tryCatch({\n      # Call the single-year function for each year\n      df &lt;- query_census(year = y,\n                         num_var = num_var,\n                         cat_var = cat_var,\n                         geo = geo,\n                         geo_values = geo_values)\n      \n      # Safety check: make sure YEAR column exists\n      if (!\"YEAR\" %in% names(df)) df$YEAR &lt;- y\n      \n      df\n    }, error = function(e) {\n      # If API request fails (e.g., missing endpoint), print a message and skip\n      message(\"Skipping year \", y, \": \", conditionMessage(e))\n      NULL\n    })\n  })\n\n  # Combine all successful yearly results into one tibble\n  dplyr::bind_rows(Filter(Negate(is.null), pieces))\n}\n\n\nLight tests (multi-year) — demonstrate each requirement is met\n\n\nShow/Hide Code\n# What years actually came back?\nm1 &lt;- query_census_multi(2019:2022)\ndplyr::count(m1, YEAR)\n\n\n# A tibble: 3 × 2\n   YEAR       n\n  &lt;int&gt;   &lt;int&gt;\n1  2019 3239553\n2  2021 3252599\n3  2022 3373378\n\n\nShow/Hide Code\n# Region filter worked?\nm2 &lt;- query_census_multi(2018:2022,\n                         num_var = c(\"JWAP\",\"PWGTP\"),\n                         cat_var = c(\"SEX\",\"JWTRNS\"),\n                         geo = \"Region\", geo_values = c(1,3))\nunique(m2$REGION)\n\n\n[1] South     Northeast\nLevels: Northeast Midwest South West\n\n\nShow/Hide Code\n# State filter (now client-side)\nm3 &lt;- query_census_multi(c(2016, 2021, 2022),\n                         num_var = c(\"AGEP\",\"PWGTP\"),\n                         cat_var = \"SEX\",\n                         geo = \"State\", geo_values = c(37,36))\nunique(m3$ST)\n\n\nNULL\n\n\n\n\n\nWe query multiple years (2019–2022). The result shows only available years are returned (e.g., skipping 2020).\nThe YEAR column is included, confirming that the wrapper correctly loops through years, applies error handling,\nand binds results.\n\n\n\nThis test repeats the regional filtering but across 2018–2022. The unique(m2$REGION) output shows only the\nrequested region codes are included, verifying that the client-side filter works consistently across multiple years.\n\n\n\nHere we test state-level filtering with geo = \"State\". The summary shows only the requested FIPS codes are\npresent in the ST column. This demonstrates that server-side state filtering is functioning properly.\nNote on Multi-Year Pulls:\nNot every year is available in the ACS1 PUMS API. For example, 2020 was disrupted by COVID and doesn’t appear at the standard endpoint. When a year is missing, the API returns a 404/400 error.\nTo handle this, my query_census_multi wrapper uses tryCatch() to skip failed years gracefully. The function prints a message like “Skipping year 2020: API request failed” and continues binding only the successful years. The result is a combined tibble with a YEAR column for downstream analysis."
  },
  {
    "objectID": "proj_1.html#data-processing",
    "href": "proj_1.html#data-processing",
    "title": "Project 1",
    "section": "",
    "text": "We implemented four main pieces: (1) a response helper, (2) a single-year query function, (3) a multi-year wrapper, and (4) categorical variable labeling.\n\nHelper- we followed our class notes: build a URL, call httr::GET(), convert the first row of the JSON to headers, then coerce types. We parameterized it with numeric_vars and categorical_vars so the same function can clean different requests without repeating code.\nSingle-year function (query_census) – This enforces the project requirements:\n\nValidates the year (2010–2022).\nRestricts variables to the allowed sets and always includes PWGTP, while requiring at least one extra numeric and one categorical.\nImplements geography. ST (state) can be filtered server-side; REGION and DIVISION are returned as columns and then filtered client-side.\nConverts JWAP and JWDP commute time codes into numeric values (minutes after midnight) by mapping each code to the midpoint of its 5-minute bin.\nApplies label_categorical_vars() so categorical variables (e.g., SEX, REGION, SCHL, JWTRNS) are returned as factors with human-readable labels.\nAttaches a YEAR column and gives the tibble an extra \"census\" class so custom methods can recognize it.\n\nMulti-year function (query_census_multi) – Calls query_census() once per year, row-binds the results, and skips unavailable endpoints (e.g., ACS1 PUMS 2020) with a message. This allows easy analysis across multiple years.\nCategorical labeling (label_categorical_vars) – A helper that maps Census codes to human-readable factor levels across variables like FER, HHL, HISPEED, JWTRNS, SCH, SCHL, SEX, REGION, DIVISION, and ST. This makes the returned tibbles easier to read and analyze while still preserving the \"census\" class for custom methods.\n\n\n\n\nSetup — load packages\n\n\nShow/Hide Code\n# Packages\nlibrary(dplyr)\nlibrary(jsonlite)\nlibrary(tibble)\nlibrary(httr)\n\n\nFirst we created a helper function.\nThe helper function handles the raw API response:\n- Builds a tibble by converting the first row of JSON into headers.\n- Coerces numeric variables when requested.\n- Leaves categorical variables as-is for labeling later.\n\n\nShow/Hide Code\nhelper &lt;- function(resp,\n                   numeric_vars = NULL,\n                   categorical_vars = NULL) {\n  parsed &lt;- fromJSON(rawToChar(resp$content))\n  \n  colnames(parsed) &lt;- parsed[1, ]     \n  dat &lt;- as_tibble(parsed[-1, ]) \n  \n  # convert numeric vars\n  if (!is.null(numeric_vars)) {\n    for (v in numeric_vars) if (v %in% names(dat)) {\n      dat[[v]] &lt;- suppressWarnings(as.numeric(dat[[v]]))\n    }\n  }\n  \n  # convert categorical vars\n  if (!is.null(categorical_vars)) {\n    for (v in categorical_vars) if (v %in% names(dat)) {\n      dat[[v]] &lt;- as.factor(dat[[v]])\n    }\n  }\n  \n  return(dat)\n}\n\n\nWe then added a label_categorical_vars() helper that replaces raw Census codes with descriptive factor labels. For example, SEX is now \"Male\"/\"Female\" instead of \"1\"/\"2\", REGION becomes \"Northeast\", \"Midwest\", \"South\", \"West\", and JWTRNS shows the actual transportation modes instead of numeric codes.\nThis step makes the returned tibble far easier to interpret and analyze, while still keeping the \"census\" class so that custom methods (summary.census, plot.census) can use these labeled factors directly.\n\n\nShow/Hide Code\nlabel_categorical_vars &lt;- function(dat) {\n \n  # FER - Gave birth to child within the past 12 months\n  if (\"FER\" %in% names(dat)) {\n    dat$FER &lt;- factor(dat$FER,\n                      levels = c(\"1\", \"2\"),\n                      labels = c(\"Yes\", \"No\"))\n  }\n \n  # HHL - Household language\n  if (\"HHL\" %in% names(dat)) {\n    dat$HHL &lt;- factor(dat$HHL,\n                      levels = c(\"1\", \"2\", \"3\", \"4\", \"5\"),\n                      labels = c(\"English only\",\n                                \"Spanish\",\n                                \"Other Indo-European\",\n                                \"Asian/Pacific Island\",\n                                \"Other\"))\n  }\n \n  # HISPEED - Broadband Internet service\n  if (\"HISPEED\" %in% names(dat)) {\n    dat$HISPEED &lt;- factor(dat$HISPEED,\n                          levels = c(\"1\", \"2\"),\n                          labels = c(\"Yes\", \"No\"))\n  }\n \n  # JWTRNS - Means of transportation to work\n  if (\"JWTRNS\" %in% names(dat)) {\n    dat$JWTRNS &lt;- factor(dat$JWTRNS,\n                         levels = c(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\",\n                                   \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"),\n                         labels = c(\"Car/truck/van\",\n                                   \"Bus\",\n                                   \"Subway/rail\",\n                                   \"Train\",\n                                   \"Light rail\",\n                                   \"Ferry\",\n                                   \"Taxi\",\n                                   \"Motorcycle\",\n                                   \"Bicycle\",\n                                   \"Walked\",\n                                   \"Work from home\",\n                                   \"Other\"))\n  }\n \n  # SCH - School enrollment\n  if (\"SCH\" %in% names(dat)) {\n    dat$SCH &lt;- factor(dat$SCH,\n                      levels = c(\"1\", \"2\", \"3\"),\n                      labels = c(\"Not in school\",\n                                \"Public school\",\n                                \"Private school\"))\n  }\n \n  # SCHL - Educational attainment\n  if (\"SCHL\" %in% names(dat)) {\n    dat$SCHL &lt;- factor(dat$SCHL,\n                       levels = c(\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\",\n                                 \"09\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\",\n                                 \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\"),\n                       labels = c(\"No schooling\",\n                                 \"Preschool\",\n                                 \"Kindergarten\",\n                                 \"Grade 1\", \"Grade 2\", \"Grade 3\", \"Grade 4\",\n                                 \"Grade 5\", \"Grade 6\", \"Grade 7\", \"Grade 8\",\n                                 \"Grade 9\", \"Grade 10\", \"Grade 11\",\n                                 \"Grade 12 - no diploma\",\n                                 \"High school diploma\",\n                                 \"GED\",\n                                 \"Some college &lt; 1 year\",\n                                 \"Some college ≥ 1 year\",\n                                 \"Associate's\",\n                                 \"Bachelor's\",\n                                 \"Master's\",\n                                 \"Professional degree\",\n                                 \"Doctorate\"))\n  }\n \n  # SEX\n  if (\"SEX\" %in% names(dat)) {\n    dat$SEX &lt;- factor(dat$SEX,\n                      levels = c(\"1\", \"2\"),\n                      labels = c(\"Male\", \"Female\"))\n  }\n \n  # REGION - Census regions\n  if (\"REGION\" %in% names(dat)) {\n    dat$REGION &lt;- factor(dat$REGION,\n                         levels = c(\"1\", \"2\", \"3\", \"4\"),\n                         labels = c(\"Northeast\", \"Midwest\", \"South\", \"West\"))\n  }\n \n  # DIVISION - Census divisions\n  if (\"DIVISION\" %in% names(dat)) {\n    dat$DIVISION &lt;- factor(dat$DIVISION,\n                           levels = c(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"),\n                           labels = c(\"New England\",\n                                     \"Middle Atlantic\",\n                                     \"East North Central\",\n                                     \"West North Central\",\n                                     \"South Atlantic\",\n                                     \"East South Central\",\n                                     \"West South Central\",\n                                     \"Mountain\",\n                                     \"Pacific\"))\n  }\n \n  # ST - State FIPS codes\n  if (\"ST\" %in% names(dat)) {\n    dat$ST &lt;- factor(dat$ST,\n                     levels = c(\"01\", \"02\", \"04\", \"05\", \"06\", \"08\", \"09\", \"10\", \"11\", \"12\",\n                               \"13\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\",\n                               \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\", \"32\", \"33\",\n                               \"34\", \"35\", \"36\", \"37\", \"38\", \"39\", \"40\", \"41\", \"42\", \"44\",\n                               \"45\", \"46\", \"47\", \"48\", \"49\", \"50\", \"51\", \"53\", \"54\", \"55\",\n                               \"56\"),\n                     labels = c(\"Alabama\", \"Alaska\", \"Arizona\", \"Arkansas\", \"California\",\n                               \"Colorado\", \"Connecticut\", \"Delaware\", \"District of Columbia\",\n                               \"Florida\", \"Georgia\", \"Hawaii\", \"Idaho\", \"Illinois\", \"Indiana\",\n                               \"Iowa\", \"Kansas\", \"Kentucky\", \"Louisiana\", \"Maine\", \"Maryland\",\n                               \"Massachusetts\", \"Michigan\", \"Minnesota\", \"Mississippi\", \"Missouri\",\n                               \"Montana\", \"Nebraska\", \"Nevada\", \"New Hampshire\", \"New Jersey\",\n                               \"New Mexico\", \"New York\", \"North Carolina\", \"North Dakota\", \"Ohio\",\n                               \"Oklahoma\", \"Oregon\", \"Pennsylvania\", \"Rhode Island\", \"South Carolina\",\n                               \"South Dakota\", \"Tennessee\", \"Texas\", \"Utah\", \"Vermont\", \"Virginia\",\n                               \"Washington\", \"West Virginia\", \"Wisconsin\", \"Wyoming\"))\n  }\n \n  return(dat)\n}\n\n\n\n\nShow/Hide Code\n# sanity check — build a URL, GET it, look at the response\n# quick, proof-of-concept\nurl_demo &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums?get=AGEP,SEX,PWGTP\"\nresp_demo &lt;- GET(url_demo)\n\n# Demo of the helper on the demo response: shows the basic flow works\ndemo_tbl &lt;- helper(resp_demo, numeric_vars = c(\"AGEP\",\"PWGTP\"), categorical_vars = \"SEX\")\nglimpse(demo_tbl) \n\n\nRows: 3,373,378\nColumns: 3\n$ AGEP  &lt;dbl&gt; 17, 73, 22, 82, 19, 88, 80, 33, 44, 36, 17, 52, 72, 29, 20, 43, …\n$ SEX   &lt;fct&gt; 2, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2…\n$ PWGTP &lt;dbl&gt; 3, 42, 11, 32, 31, 32, 45, 37, 29, 55, 12, 41, 14, 3, 119, 91, 3…\n\n\nThen we created the main function of the project: the query_census function. This function wraps the entire workflow: it validates the year (only allowing 2010–2022), enforces the rule that PWGTP must always be included, checks that the requested variables are from the allowed sets, and handles geography. States can be filtered server-side with an ST parameter, while Regions and Divisions are requested in the data and then filtered client-side.\nWe also had to deal with commute time variables (JWAP and JWDP). These are stored as codes for 5-minute bins, so we wrote a converter that maps each code to the midpoint minutes after midnight. That way, we can analyze them as real numeric times. Finally, we applied the categorical labels and tagged the tibble with a custom \"census\" class so we can write methods for it later.\n\n\nShow/Hide Code\nquery_census &lt;- function(year = 2022,\n                         num_var = c(\"AGEP\",\"PWGTP\"),\n                         cat_var = \"SEX\",\n                         geo = c(\"All\",\"Region\",\"Division\",\"State\"),\n                         geo_values = NULL) {\n  library(httr); library(jsonlite); library(tibble); library(dplyr)\n\n  if (!is.numeric(year) || length(year) != 1 || year &lt; 2010 || year &gt; 2022)\n    stop(\"year must be a single number in 2010–2022\", call. = FALSE)\n\n  # always include PWGTP\n  if (!\"PWGTP\" %in% num_var) num_var &lt;- c(\"PWGTP\", num_var)\n\n  num_allowed &lt;- c(\"AGEP\",\"GASP\",\"GRPIP\",\"JWAP\",\"JWDP\",\"JWMNP\",\"PWGTP\")\n  cat_allowed &lt;- c(\"FER\",\"HHL\",\"HISPEED\",\"JWTRNS\",\"SCH\",\"SCHL\",\"SEX\")\n\n  num_var &lt;- toupper(num_var); cat_var &lt;- toupper(cat_var)\n  stopifnot(all(num_var %in% num_allowed), all(cat_var %in% cat_allowed))\n  if (length(setdiff(num_var,\"PWGTP\")) &lt; 1) stop(\"need ≥1 numeric besides PWGTP\")\n  if (length(cat_var) &lt; 1) stop(\"need ≥1 categorical\")\n\n  geo &lt;- match.arg(geo)\n  # only ST can be filtered server-side; REGION/DIVISION will be filtered client-side\n  geog_var &lt;- switch(geo,\n    \"All\"      = NULL,\n    \"State\"    = \"ST\",\n    \"Region\"   = \"REGION\",\n    \"Division\" = \"DIVISION\"\n  )\n\n  # ---- build URL: no REGION/DIVISION in query string ----\n  base &lt;- sprintf(\"https://api.census.gov/data/%d/acs/acs1/pums\", as.integer(year))\n  get_vars &lt;- paste(c(unique(num_var), unique(cat_var),\n                      # include REGION/DIVISION in the return set if the user asked for them\n                      if (geo %in% c(\"Region\",\"Division\")) geog_var),\n                    collapse = \",\")\n  qs &lt;- paste0(\"get=\", get_vars)\n\n  # only add ST filter to URL; others will be post-filtered\n  geo_part &lt;- \"\"\n  if (!is.null(geog_var) && geog_var == \"ST\" && length(geo_values)) {\n    geo_vals &lt;- paste0(\"ST=\", geo_values)\n    geo_part &lt;- paste0(\"&\", paste(geo_vals, collapse = \"&\"))\n  }\n\n  url &lt;- paste0(base, \"?\", qs, geo_part)\n\n  resp &lt;- GET(url)\n  if (resp$status_code != 200) stop(\"API request failed (\", resp$status_code, \"): \", url, call. = FALSE)\n\n  # use helper() to parse and type most vars; time vars handled below\n  time_vars &lt;- intersect(num_var, c(\"JWAP\",\"JWDP\"))\n  numeric_for_helper &lt;- setdiff(num_var, time_vars)\n  dat &lt;- helper(resp, numeric_vars = numeric_for_helper)  # Remove categorical_vars argument\n\n # time bins → midpoint minutes (for 5-minute bins)\njw_to_minutes &lt;- function(x) {\n  code &lt;- suppressWarnings(as.numeric(as.character(x)))\n  ok &lt;- !is.na(code) & code &gt;= 1 & code &lt;= 288\n  out &lt;- rep(NA_real_, length(x))\n  out[ok] &lt;- (code[ok] - 1) * 5 + 2.5  # Midpoint of each 5-minute bin\n  return(out)\n}\n  if (\"JWAP\" %in% names(dat)) dat$JWAP &lt;- jw_to_minutes(dat$JWAP)\n  if (\"JWDP\" %in% names(dat)) dat$JWDP &lt;- jw_to_minutes(dat$JWDP)\n\n \n\n  # client-side filter for Region/Division if requested\n  if (geo == \"Region\" && length(geo_values)) {\n    if (!\"REGION\" %in% names(dat)) stop(\"REGION not returned; add it to get=.\")\n    dat &lt;- dat %&gt;% filter(.data$REGION %in% as.character(geo_values))\n  }\n  if (geo == \"Division\" && length(geo_values)) {\n    if (!\"DIVISION\" %in% names(dat)) stop(\"DIVISION not returned; add it to get=.\")\n    dat &lt;- dat %&gt;% filter(.data$DIVISION %in% as.character(geo_values))\n  }\n dat &lt;- label_categorical_vars(dat)\n  dat$YEAR &lt;- as.integer(year)\n  class(dat) &lt;- c(\"census\", class(dat))\n  dat\n}\n\n\nLight tests (single year) — demonstrate each requirement is met:\n\n\nShow/Hide Code\n# simple default\nd1 &lt;- query_census()\n\n# region subset, with a time variable\nd2 &lt;- query_census(year = 2022,\n                   num_var = c(\"JWAP\",\"PWGTP\"),\n                   cat_var = c(\"SEX\",\"JWTRNS\"),\n                   geo = \"Region\", geo_values = c(1,3))\n\nglimpse(d2)\n\n\nRows: 1,871,742\nColumns: 6\n$ JWAP   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, 432.5, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ PWGTP  &lt;dbl&gt; 42, 31, 32, 45, 55, 41, 119, 24, 6, 25, 50, 80, 48, 59, 21, 145…\n$ SEX    &lt;fct&gt; Male, Female, Male, Male, Male, Male, Male, Male, Male, Male, M…\n$ JWTRNS &lt;fct&gt; NA, NA, NA, NA, NA, NA, Car/truck/van, NA, NA, Work from home, …\n$ REGION &lt;fct&gt; South, Northeast, South, South, South, South, South, Northeast,…\n$ YEAR   &lt;int&gt; 2022, 2022, 2022, 2022, 2022, 2022, 2022, 2022, 2022, 2022, 202…\n\n\n\n\nThis test calls our function where we add a time variable (JWAP) and a categorical (JWTRNS), filtering to two regions.\nThe output tibble contains JWAP converted to minutes, SEX labeled, and JWTRNS with descriptive categories.\nThe REGION column is present, and filtering reduces the dataset to the requested regions.\nThis shows that client-side filtering is working correctly.\n\nFinally, we wanted to study multiple years at once. To do this efficiently, we wrote query_census_multi(), which loops over a vector of years with lapply(). For each year, it calls query_census(). If a year fails (because the API endpoint doesn’t exist, like in 2020), it gets skipped with a message. All the successful results are then bound together into a single tibble with a YEAR column for comparison.\n\n\nShow/Hide Code\nquery_census_multi &lt;- function(years,\n                               num_var = c(\"AGEP\",\"PWGTP\"),\n                               cat_var = \"SEX\",\n                               geo = c(\"All\",\"Region\",\"Division\",\"State\"),\n                               geo_values = NULL) {\n  # Convert input years to integers\n  years &lt;- as.integer(years)\n  \n  # Ensure at least one year is provided\n  if (length(years) &lt; 1) stop(\"Provide at least one year.\", call. = FALSE)\n\n  # Loop over each year with lapply\n  pieces &lt;- lapply(years, function(y) {\n    tryCatch({\n      # Call the single-year function for each year\n      df &lt;- query_census(year = y,\n                         num_var = num_var,\n                         cat_var = cat_var,\n                         geo = geo,\n                         geo_values = geo_values)\n      \n      # Safety check: make sure YEAR column exists\n      if (!\"YEAR\" %in% names(df)) df$YEAR &lt;- y\n      \n      df\n    }, error = function(e) {\n      # If API request fails (e.g., missing endpoint), print a message and skip\n      message(\"Skipping year \", y, \": \", conditionMessage(e))\n      NULL\n    })\n  })\n\n  # Combine all successful yearly results into one tibble\n  dplyr::bind_rows(Filter(Negate(is.null), pieces))\n}\n\n\nLight tests (multi-year) — demonstrate each requirement is met\n\n\nShow/Hide Code\n# What years actually came back?\nm1 &lt;- query_census_multi(2019:2022)\ndplyr::count(m1, YEAR)\n\n\n# A tibble: 3 × 2\n   YEAR       n\n  &lt;int&gt;   &lt;int&gt;\n1  2019 3239553\n2  2021 3252599\n3  2022 3373378\n\n\nShow/Hide Code\n# Region filter worked?\nm2 &lt;- query_census_multi(2018:2022,\n                         num_var = c(\"JWAP\",\"PWGTP\"),\n                         cat_var = c(\"SEX\",\"JWTRNS\"),\n                         geo = \"Region\", geo_values = c(1,3))\nunique(m2$REGION)\n\n\n[1] South     Northeast\nLevels: Northeast Midwest South West\n\n\nShow/Hide Code\n# State filter (now client-side)\nm3 &lt;- query_census_multi(c(2016, 2021, 2022),\n                         num_var = c(\"AGEP\",\"PWGTP\"),\n                         cat_var = \"SEX\",\n                         geo = \"State\", geo_values = c(37,36))\nunique(m3$ST)\n\n\nNULL\n\n\n\n\n\nWe query multiple years (2019–2022). The result shows only available years are returned (e.g., skipping 2020).\nThe YEAR column is included, confirming that the wrapper correctly loops through years, applies error handling,\nand binds results.\n\n\n\nThis test repeats the regional filtering but across 2018–2022. The unique(m2$REGION) output shows only the\nrequested region codes are included, verifying that the client-side filter works consistently across multiple years.\n\n\n\nHere we test state-level filtering with geo = \"State\". The summary shows only the requested FIPS codes are\npresent in the ST column. This demonstrates that server-side state filtering is functioning properly.\nNote on Multi-Year Pulls:\nNot every year is available in the ACS1 PUMS API. For example, 2020 was disrupted by COVID and doesn’t appear at the standard endpoint. When a year is missing, the API returns a 404/400 error.\nTo handle this, my query_census_multi wrapper uses tryCatch() to skip failed years gracefully. The function prints a message like “Skipping year 2020: API request failed” and continues binding only the successful years. The result is a combined tibble with a YEAR column for downstream analysis."
  },
  {
    "objectID": "proj_1.html#writing-a-generic-function-for-summarizing",
    "href": "proj_1.html#writing-a-generic-function-for-summarizing",
    "title": "Project 1",
    "section": "2 Writing a Generic Function for Summarizing",
    "text": "2 Writing a Generic Function for Summarizing\nThe summary.census() function calculates weighted summary statistics for data returned by query_census(). It uses the PWGTP column, which contains person weights representing how many people in the U.S. population each survey respondent corresponds to. For numeric variables, the function reports weighted means and standard deviations, while for categorical variables it produces weighted counts and proportions. By default, all numeric columns except PWGTP and YEAR are summarized, and all factor columns are treated as categorical variables. The function returns a list containing two data frames: one with the numeric summaries and one with the categorical summaries.\n\n\nShow/Hide Code\nsummary.census &lt;- function(object, numeric_vars = NULL, categorical_vars = NULL) {\n \n# Check that the object has the \"census\" class assigned by query_census()\n  if (!(\"census\" %in% class(object))) {\n    stop(\"Object must have class 'census'\")\n  }\n# Check that the weights column exists as it is required for all calculations\n  if (!(\"PWGTP\" %in% names(object))) {\n    stop(\"PWGTP (weights) column not found.\")\n  }\n \n  # If user didn't specify which numeric variables to summarize,find all numeric columns except PWGTP (the weight) and YEAR\n  if (is.null(numeric_vars)) {\n    numeric_vars &lt;- c()\n    # Loop through all column names\n    for (col_name in names(object)) {\n      # Check if column is numeric AND not PWGTP or YEAR\n      if (is.numeric(object[[col_name]]) && col_name != \"PWGTP\" && col_name != \"YEAR\") {\n        numeric_vars &lt;- c(numeric_vars, col_name)\n      }\n    }\n  }\n  # If user didn't specify which categorical variables to summarize,\n  # find all factor columns (categorical data is stored as factors)\n  if (is.null(categorical_vars)) {\n    categorical_vars &lt;- c()\n    # Loop through all column names\n    for (col_name in names(object)) {\n      # Check if column is a factor\n      if (is.factor(object[[col_name]])) {\n        categorical_vars &lt;- c(categorical_vars, col_name)\n      }\n    }\n  }\n  # Get the weights vector\n  w &lt;- object$PWGTP  \n \n  # Create numeric summary with a loop create an empty data frame to store results and add one row for each numeric variable\n  numeric_results &lt;- data.frame()\n \n   # Loop through each numeric variable\n  for (var in numeric_vars) {\n    x &lt;- object[[var]]\n   \n    # Remove NA values\n    valid &lt;- !is.na(x) & !is.na(w)\n    x_clean &lt;- x[valid]\n    w_clean &lt;- w[valid]\n   \n    # Only calculate if there is data after removing NAs\n    if (length(x_clean) &gt; 0) {\n      # Calculate weighted mean\n      weighted_mean &lt;- sum(x_clean * w_clean) / sum(w_clean)\n     \n      # Calculate weighted SD\n      weighted_sd &lt;- sqrt(sum((x_clean^2) * w_clean) / sum(w_clean) - weighted_mean^2)\n     \n      # Add row of results to a data frame\n      new_row &lt;- data.frame(\n        variable = var,\n        weighted_mean = weighted_mean,\n        weighted_sd = weighted_sd,\n        n = length(x_clean),\n        weight_sum = sum(w_clean)\n      )\n     \n   # Add the results row above to a results data frame\n\n      numeric_results &lt;- rbind(numeric_results, new_row)\n    }\n  }\n \n  # Create categorical summary with a loop\n  categorical_results &lt;- data.frame()\n \n  for (var in categorical_vars) {\n    f &lt;- object[[var]]\n   \n    # Remove NA values\n    valid &lt;- !is.na(f) & !is.na(w)\n    f_clean &lt;- f[valid]\n    w_clean &lt;- w[valid]\n   \n    # Only calculate if there is data after removing NAs\n    if (length(f_clean) &gt; 0) {\n     \n    # droplevels() removes any factor levels that don't appear in the     data\n      levels_list &lt;- levels(droplevels(f_clean))\n     \n      # Calculate weighted sum for each level\n      for (lev in levels_list) {\n        mask &lt;- f_clean == lev\n       \n        # Sum weights for this level only\n        weighted_n &lt;- sum(w_clean[mask])\n       \n       # Calculate total weight\n        total_weight &lt;- sum(w_clean)\n       # Create a data frame with results for this level\n        new_row &lt;- data.frame(\n          variable = var,\n          level = lev,\n          weighted_n = weighted_n,\n          prop = weighted_n / total_weight\n        )\n       \n        categorical_results &lt;- rbind(categorical_results, new_row)\n      }\n    }\n  }\n   # Return a named list with two data frames\n  list(numeric = numeric_results, categorical = categorical_results)\n}\n\n\nWe created a custom plotting method, plot.census(), to visualize Census data with weighted boxplots. The function takes one categorical and one numeric variable, converts them to the right types, and uses survey weights (PWGTP) in the plot. A set of descriptive labels replaces variable codes (e.g., AGEP → “Age (years)”) to make axes and titles easier to read. This provides a quick way to compare numeric outcomes across demographic groups.\n\n\nShow/Hide Code\nlibrary(ggplot2)\nplot.census &lt;- function(x, cat_var, num_var, ...) {\n  # Ensure categorical variable is treated as a factor\n  x[[cat_var]] &lt;- as.factor(x[[cat_var]])\n  # Ensure numeric variable is treated as numeric\n  x[[num_var]] &lt;- as.numeric(x[[num_var]])\n \n  # Descriptive labels\n  var_labels &lt;- c(\n    \"AGEP\" = \"Age (years)\",\n    \"JWAP\" = \"Arrival Time at Work (minutes after midnight)\",\n    \"JWDP\" = \"Departure Time for Work (minutes after midnight)\",\n    \"JWMNP\" = \"Travel Time to Work (minutes)\",\n    \"GASP\" = \"Monthly Gas Cost ($)\",\n    \"GRPIP\" = \"Gross Rent as % of Income\",\n    \"SEX\" = \"Sex\",\n    \"JWTRNS\" = \"Mode of Transportation\",\n    \"SCHL\" = \"Educational Attainment\",\n    \"SCH\" = \"School Enrollment\"\n  )\n \n  # Look up user-friendly axis labels if available, otherwise use raw variable names\n  x_label &lt;- ifelse(cat_var %in% names(var_labels), var_labels[cat_var], cat_var)\n  y_label &lt;- ifelse(num_var %in% names(var_labels), var_labels[num_var], num_var)\n \n  # Build weighted boxplot using ggplot2\n  ggplot(x, aes(x = get(cat_var), y = get(num_var), weight = PWGTP)) +\n    geom_boxplot() +\n    labs(\n      x = x_label,\n      y = y_label,\n      title = paste(y_label, \"by\", x_label)\n    ) +\n    theme_minimal() +\n    theme(axis.text.x = element_text(angle = 45, hjust = 1))  \n}"
  },
  {
    "objectID": "proj_1.html#mini-investigation-commute-time-by-transportation-mode-and-by-sex-2022",
    "href": "proj_1.html#mini-investigation-commute-time-by-transportation-mode-and-by-sex-2022",
    "title": "Project 1",
    "section": "3 Mini-investigation: Commute time by transportation mode (and by sex), 2022",
    "text": "3 Mini-investigation: Commute time by transportation mode (and by sex), 2022\nTo explore something meaningful from the ACS microdata, we focused on commuting patterns. Using our query_census() function, we requested 2022 data on time of departure/arrival, travel time (JWMNP), mode of transport (JWTRNS), and sex (SEX).\nWe then passed the result to our summary.census() function. The numeric summary confirmed that average commute times cluster around 25–30 minutes, but with wide variation depending on the mode of transport. The categorical summary showed that car/truck/van remains the dominant mode, while public transit modes (bus, subway/rail) represent smaller but nontrivial shares.\nFinally, we visualized the relationship with our plot.census() function. The boxplot below shows that commute time varies strongly by mode of transportation. Subway/rail and ferry users have much higher median commute times and wider variability, reflecting longer distances and transfer delays. In contrast, walking and working from home sit near zero, while car commutes cluster tightly around 20–30 minutes.\n\n\nShow/Hide Code\n# Pull 2022 commute data: numeric = JWMNP (commute minutes), PWGTP (weights)\n# categorical = JWTRNS (mode), SEX (for subgrouping/labels)\nd22 &lt;- query_census(\n  year    = 2022,\n  num_var = c(\"JWMNP\",\"PWGTP\"),\n  cat_var = c(\"JWTRNS\",\"SEX\"),\n  geo     = \"All\"\n)\n\n# Weighted summaries using summary.census()\ns22 &lt;- summary.census(\n  d22,\n  numeric_vars     = c(\"JWMNP\"),   # summarize commute time\n  categorical_vars = c(\"JWTRNS\",\"SEX\")\n)\n\n# View numeric summary\nglimpse(s22$numeric)\n\n\nRows: 1\nColumns: 5\n$ variable      &lt;chr&gt; \"JWMNP\"\n$ weighted_mean &lt;dbl&gt; 10.79463\n$ weighted_sd   &lt;dbl&gt; 19.28697\n$ n             &lt;int&gt; 3373378\n$ weight_sum    &lt;dbl&gt; 333287562\n\n\nShow/Hide Code\n# View categorical summary\nglimpse(s22$categorical)\n\n\nRows: 14\nColumns: 4\n$ variable   &lt;chr&gt; \"JWTRNS\", \"JWTRNS\", \"JWTRNS\", \"JWTRNS\", \"JWTRNS\", \"JWTRNS\",…\n$ level      &lt;chr&gt; \"Car/truck/van\", \"Bus\", \"Subway/rail\", \"Train\", \"Light rail…\n$ weighted_n &lt;dbl&gt; 124224522, 2408456, 1935738, 466319, 127562, 63463, 385299,…\n$ prop       &lt;dbl&gt; 0.7730161858, 0.0149871816, 0.0120455831, 0.0029017792, 0.0…\n\n\nShow/Hide Code\n# Weighted boxplot of commute time by transportation mode (uses PWGTP internally)\nplot.census(d22, \"JWTRNS\", \"JWMNP\")\n\n\n\n\n\n\n\n\n\nTogether, the summaries and visualization confirm that mode of transportation is the key driver of commute duration, more so than demographic splits by sex. This investigation demonstrates how our pipeline—API query, weighted summary, and weighted visualization—can be applied to extract insights from ACS PUMS data."
  }
]