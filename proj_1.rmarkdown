---
title: "Project 1"
format: html
editor: visual
---



## Data Processing

### What we built and why

We implemented four main pieces: **(1) a response helper, (2) a single-year query function, (3) a multi-year wrapper, and (4) categorical variable labeling.**

1.  Helper- we followed our class notes: build a URL, call `httr::GET()`, convert the first row of the JSON to headers, then coerce types. We parameterized it with `numeric_vars` and `categorical_vars` so the same function can clean different requests without repeating code.
2.  **Single-year function (`query_census`)** – This enforces the project requirements:
    1.  Validates the **year** (2010–2022).
    2.  Restricts variables to the **allowed sets** and **always includes `PWGTP`**, while requiring at least one **extra** numeric and one categorical.
    3.  Implements **geography**. `ST` (state) can be filtered server-side; `REGION` and `DIVISION` are returned as columns and then filtered client-side.
    4.  Converts `JWAP` and `JWDP` commute time codes into numeric values (minutes after midnight) by mapping each code to the midpoint of its 5-minute bin.
    5.  Applies `label_categorical_vars()` so categorical variables (e.g., `SEX`, `REGION`, `SCHL`, `JWTRNS`) are returned as factors with human-readable labels.
    6.  Attaches a `YEAR` column and gives the tibble an extra `"census"` class so custom methods can recognize it.
3.  **Multi-year function (`query_census_multi`)** – Calls `query_census()` once per year, row-binds the results, and skips unavailable endpoints (e.g., ACS1 PUMS 2020) with a message. This allows easy analysis across multiple years.
4.  **Categorical labeling (`label_categorical_vars`)** – A helper that maps Census codes to human-readable factor levels across variables like `FER`, `HHL`, `HISPEED`, `JWTRNS`, `SCH`, `SCHL`, `SEX`, `REGION`, `DIVISION`, and `ST`. This makes the returned tibbles easier to read and analyze while still preserving the `"census"` class for custom methods.

### Implementation

Setup — load packages



```{r}
# Packages
library(dplyr)
library(jsonlite)
library(tibble)
library(httr)
```



First we created a helper function.

The helper function handles the raw API response:\
- Builds a tibble by converting the first row of JSON into headers.\
- Coerces numeric variables when requested.\
- Leaves categorical variables as-is for labeling later.



```{r}

helper <- function(resp,
                   numeric_vars = NULL,
                   categorical_vars = NULL) {
  parsed <- fromJSON(rawToChar(resp$content))
  
  colnames(parsed) <- parsed[1, ]     
  dat <- as_tibble(parsed[-1, ]) 
  
  # convert numeric vars
  if (!is.null(numeric_vars)) {
    for (v in numeric_vars) if (v %in% names(dat)) {
      dat[[v]] <- suppressWarnings(as.numeric(dat[[v]]))
    }
  }
  
  # convert categorical vars
  if (!is.null(categorical_vars)) {
    for (v in categorical_vars) if (v %in% names(dat)) {
      dat[[v]] <- as.factor(dat[[v]])
    }
  }
  
  return(dat)
}
```



We then added a `label_categorical_vars()` helper that replaces raw Census codes with descriptive factor labels. For example, `SEX` is now `"Male"`/`"Female"` instead of `"1"`/`"2"`, `REGION` becomes `"Northeast"`, `"Midwest"`, `"South"`, `"West"`, and `JWTRNS` shows the actual transportation modes instead of numeric codes.

This step makes the returned tibble far easier to interpret and analyze, while still keeping the `"census"` class so that custom methods (`summary.census`, `plot.census`) can use these labeled factors directly.



```{r}
label_categorical_vars <- function(dat) {
 
  # FER - Gave birth to child within the past 12 months
  if ("FER" %in% names(dat)) {
    dat$FER <- factor(dat$FER,
                      levels = c("1", "2"),
                      labels = c("Yes", "No"))
  }
 
  # HHL - Household language
  if ("HHL" %in% names(dat)) {
    dat$HHL <- factor(dat$HHL,
                      levels = c("1", "2", "3", "4", "5"),
                      labels = c("English only",
                                "Spanish",
                                "Other Indo-European",
                                "Asian/Pacific Island",
                                "Other"))
  }
 
  # HISPEED - Broadband Internet service
  if ("HISPEED" %in% names(dat)) {
    dat$HISPEED <- factor(dat$HISPEED,
                          levels = c("1", "2"),
                          labels = c("Yes", "No"))
  }
 
  # JWTRNS - Means of transportation to work
  if ("JWTRNS" %in% names(dat)) {
    dat$JWTRNS <- factor(dat$JWTRNS,
                         levels = c("1", "2", "3", "4", "5", "6",
                                   "7", "8", "9", "10", "11", "12"),
                         labels = c("Car/truck/van",
                                   "Bus",
                                   "Subway/rail",
                                   "Train",
                                   "Light rail",
                                   "Ferry",
                                   "Taxi",
                                   "Motorcycle",
                                   "Bicycle",
                                   "Walked",
                                   "Work from home",
                                   "Other"))
  }
 
  # SCH - School enrollment
  if ("SCH" %in% names(dat)) {
    dat$SCH <- factor(dat$SCH,
                      levels = c("1", "2", "3"),
                      labels = c("Not in school",
                                "Public school",
                                "Private school"))
  }
 
  # SCHL - Educational attainment
  if ("SCHL" %in% names(dat)) {
    dat$SCHL <- factor(dat$SCHL,
                       levels = c("01", "02", "03", "04", "05", "06", "07", "08",
                                 "09", "10", "11", "12", "13", "14", "15", "16",
                                 "17", "18", "19", "20", "21", "22", "23", "24"),
                       labels = c("No schooling",
                                 "Preschool",
                                 "Kindergarten",
                                 "Grade 1", "Grade 2", "Grade 3", "Grade 4",
                                 "Grade 5", "Grade 6", "Grade 7", "Grade 8",
                                 "Grade 9", "Grade 10", "Grade 11",
                                 "Grade 12 - no diploma",
                                 "High school diploma",
                                 "GED",
                                 "Some college < 1 year",
                                 "Some college ≥ 1 year",
                                 "Associate's",
                                 "Bachelor's",
                                 "Master's",
                                 "Professional degree",
                                 "Doctorate"))
  }
 
  # SEX
  if ("SEX" %in% names(dat)) {
    dat$SEX <- factor(dat$SEX,
                      levels = c("1", "2"),
                      labels = c("Male", "Female"))
  }
 
  # REGION - Census regions
  if ("REGION" %in% names(dat)) {
    dat$REGION <- factor(dat$REGION,
                         levels = c("1", "2", "3", "4"),
                         labels = c("Northeast", "Midwest", "South", "West"))
  }
 
  # DIVISION - Census divisions
  if ("DIVISION" %in% names(dat)) {
    dat$DIVISION <- factor(dat$DIVISION,
                           levels = c("1", "2", "3", "4", "5", "6", "7", "8", "9"),
                           labels = c("New England",
                                     "Middle Atlantic",
                                     "East North Central",
                                     "West North Central",
                                     "South Atlantic",
                                     "East South Central",
                                     "West South Central",
                                     "Mountain",
                                     "Pacific"))
  }
 
  # ST - State FIPS codes
  if ("ST" %in% names(dat)) {
    dat$ST <- factor(dat$ST,
                     levels = c("01", "02", "04", "05", "06", "08", "09", "10", "11", "12",
                               "13", "15", "16", "17", "18", "19", "20", "21", "22", "23",
                               "24", "25", "26", "27", "28", "29", "30", "31", "32", "33",
                               "34", "35", "36", "37", "38", "39", "40", "41", "42", "44",
                               "45", "46", "47", "48", "49", "50", "51", "53", "54", "55",
                               "56"),
                     labels = c("Alabama", "Alaska", "Arizona", "Arkansas", "California",
                               "Colorado", "Connecticut", "Delaware", "District of Columbia",
                               "Florida", "Georgia", "Hawaii", "Idaho", "Illinois", "Indiana",
                               "Iowa", "Kansas", "Kentucky", "Louisiana", "Maine", "Maryland",
                               "Massachusetts", "Michigan", "Minnesota", "Mississippi", "Missouri",
                               "Montana", "Nebraska", "Nevada", "New Hampshire", "New Jersey",
                               "New Mexico", "New York", "North Carolina", "North Dakota", "Ohio",
                               "Oklahoma", "Oregon", "Pennsylvania", "Rhode Island", "South Carolina",
                               "South Dakota", "Tennessee", "Texas", "Utah", "Vermont", "Virginia",
                               "Washington", "West Virginia", "Wisconsin", "Wyoming"))
  }
 
  return(dat)
}
```

```{r}
# sanity check — build a URL, GET it, look at the response
# quick, proof-of-concept
url_demo <- "https://api.census.gov/data/2022/acs/acs1/pums?get=AGEP,SEX,PWGTP"
resp_demo <- GET(url_demo)

# Demo of the helper on the demo response: shows the basic flow works
demo_tbl <- helper(resp_demo, numeric_vars = c("AGEP","PWGTP"), categorical_vars = "SEX")
glimpse(demo_tbl) 
```



Then we created the main function of the project: the query_census function. This function wraps the entire workflow: it validates the year (only allowing 2010–2022), enforces the rule that `PWGTP` must always be included, checks that the requested variables are from the allowed sets, and handles geography. States can be filtered server-side with an `ST` parameter, while Regions and Divisions are requested in the data and then filtered client-side.

We also had to deal with commute time variables (`JWAP` and `JWDP`). These are stored as codes for 5-minute bins, so we wrote a converter that maps each code to the midpoint minutes after midnight. That way, we can analyze them as real numeric times. Finally, we applied the categorical labels and tagged the tibble with a custom `"census"` class so we can write methods for it later.



```{r}
query_census <- function(year = 2022,
                         num_var = c("AGEP","PWGTP"),
                         cat_var = "SEX",
                         geo = c("All","Region","Division","State"),
                         geo_values = NULL) {
  library(httr); library(jsonlite); library(tibble); library(dplyr)

  if (!is.numeric(year) || length(year) != 1 || year < 2010 || year > 2022)
    stop("year must be a single number in 2010–2022", call. = FALSE)

  # always include PWGTP
  if (!"PWGTP" %in% num_var) num_var <- c("PWGTP", num_var)

  num_allowed <- c("AGEP","GASP","GRPIP","JWAP","JWDP","JWMNP","PWGTP")
  cat_allowed <- c("FER","HHL","HISPEED","JWTRNS","SCH","SCHL","SEX")

  num_var <- toupper(num_var); cat_var <- toupper(cat_var)
  stopifnot(all(num_var %in% num_allowed), all(cat_var %in% cat_allowed))
  if (length(setdiff(num_var,"PWGTP")) < 1) stop("need ≥1 numeric besides PWGTP")
  if (length(cat_var) < 1) stop("need ≥1 categorical")

  geo <- match.arg(geo)
  # only ST can be filtered server-side; REGION/DIVISION will be filtered client-side
  geog_var <- switch(geo,
    "All"      = NULL,
    "State"    = "ST",
    "Region"   = "REGION",
    "Division" = "DIVISION"
  )

  # ---- build URL: no REGION/DIVISION in query string ----
  base <- sprintf("https://api.census.gov/data/%d/acs/acs1/pums", as.integer(year))
  get_vars <- paste(c(unique(num_var), unique(cat_var),
                      # include REGION/DIVISION in the return set if the user asked for them
                      if (geo %in% c("Region","Division")) geog_var),
                    collapse = ",")
  qs <- paste0("get=", get_vars)

  # only add ST filter to URL; others will be post-filtered
  geo_part <- ""
  if (!is.null(geog_var) && geog_var == "ST" && length(geo_values)) {
    geo_vals <- paste0("ST=", geo_values)
    geo_part <- paste0("&", paste(geo_vals, collapse = "&"))
  }

  url <- paste0(base, "?", qs, geo_part)

  resp <- GET(url)
  if (resp$status_code != 200) stop("API request failed (", resp$status_code, "): ", url, call. = FALSE)

  # use helper() to parse and type most vars; time vars handled below
  time_vars <- intersect(num_var, c("JWAP","JWDP"))
  numeric_for_helper <- setdiff(num_var, time_vars)
  dat <- helper(resp, numeric_vars = numeric_for_helper)  # Remove categorical_vars argument

 # time bins → midpoint minutes (for 5-minute bins)
jw_to_minutes <- function(x) {
  code <- suppressWarnings(as.numeric(as.character(x)))
  ok <- !is.na(code) & code >= 1 & code <= 288
  out <- rep(NA_real_, length(x))
  out[ok] <- (code[ok] - 1) * 5 + 2.5  # Midpoint of each 5-minute bin
  return(out)
}
  if ("JWAP" %in% names(dat)) dat$JWAP <- jw_to_minutes(dat$JWAP)
  if ("JWDP" %in% names(dat)) dat$JWDP <- jw_to_minutes(dat$JWDP)

 

  # client-side filter for Region/Division if requested
  if (geo == "Region" && length(geo_values)) {
    if (!"REGION" %in% names(dat)) stop("REGION not returned; add it to get=.")
    dat <- dat %>% filter(.data$REGION %in% as.character(geo_values))
  }
  if (geo == "Division" && length(geo_values)) {
    if (!"DIVISION" %in% names(dat)) stop("DIVISION not returned; add it to get=.")
    dat <- dat %>% filter(.data$DIVISION %in% as.character(geo_values))
  }
 dat <- label_categorical_vars(dat)
  dat$YEAR <- as.integer(year)
  class(dat) <- c("census", class(dat))
  dat
}

```



Light tests (single year) — demonstrate each requirement is met



```{r}
# simple default
d1 <- query_census()

# region subset, with a time variable
d2 <- query_census(year = 2022,
                   num_var = c("JWAP","PWGTP"),
                   cat_var = c("SEX","JWTRNS"),
                   geo = "Region", geo_values = c(1,3))

glimpse(d2)


```



Finally, we wanted to study multiple years at once. To do this efficiently, we wrote **`query_census_multi()`**, which loops over a vector of years with `lapply()`. For each year, it calls `query_census()`. If a year fails (because the API endpoint doesn’t exist, like in 2020), it gets skipped with a message. All the successful results are then bound together into a single tibble with a `YEAR` column for comparison.



```{r}
query_census_multi <- function(years,
                               num_var = c("AGEP","PWGTP"),
                               cat_var = "SEX",
                               geo = c("All","Region","Division","State"),
                               geo_values = NULL) {
  # Convert input years to integers
  years <- as.integer(years)
  
  # Ensure at least one year is provided
  if (length(years) < 1) stop("Provide at least one year.", call. = FALSE)

  # Loop over each year with lapply
  pieces <- lapply(years, function(y) {
    tryCatch({
      # Call the single-year function for each year
      df <- query_census(year = y,
                         num_var = num_var,
                         cat_var = cat_var,
                         geo = geo,
                         geo_values = geo_values)
      
      # Safety check: make sure YEAR column exists
      if (!"YEAR" %in% names(df)) df$YEAR <- y
      
      df
    }, error = function(e) {
      # If API request fails (e.g., missing endpoint), print a message and skip
      message("Skipping year ", y, ": ", conditionMessage(e))
      NULL
    })
  })

  # Combine all successful yearly results into one tibble
  dplyr::bind_rows(Filter(Negate(is.null), pieces))
}
```



Light tests (multi-year) — demonstrate each requirement is met



```{r}
# What years actually came back?
m1 <- query_census_multi(2019:2022)
dplyr::count(m1, YEAR)

# Region filter worked?
m2 <- query_census_multi(2018:2022,
                         num_var = c("JWAP","PWGTP"),
                         cat_var = c("SEX","JWTRNS"),
                         geo = "Region", geo_values = c(1,3))
unique(m2$REGION)

# State filter (now client-side)
m3 <- query_census_multi(c(2016, 2021, 2022),
                         num_var = c("AGEP","PWGTP"),
                         cat_var = "SEX",
                         geo = "State", geo_values = c(37,36))
unique(m3$ST)

```



Note on Multi-Year Pulls:

Not every year is available in the ACS1 PUMS API. For example, **2020** was disrupted by COVID and doesn’t appear at the standard endpoint. When a year is missing, the API returns a **404/400 error**.

To handle this, my `query_census_multi` wrapper uses `tryCatch()` to **skip failed years gracefully**. The function prints a message like *“Skipping year 2020: API request failed”* and continues binding only the successful years. The result is a combined tibble with a `YEAR` column for downstream analysis.

## Writing a Generic Function for Summarizing

The `summary.census()` function calculates weighted summary statistics for data returned by `query_census()`. It uses the `PWGTP` column, which contains person weights representing how many people in the U.S. population each survey respondent corresponds to. For numeric variables, the function reports weighted means and standard deviations, while for categorical variables it produces weighted counts and proportions. By default, all numeric columns except `PWGTP` and `YEAR` are summarized, and all factor columns are treated as categorical variables. The function returns a list containing two data frames: one with the numeric summaries and one with the categorical summaries.



```{r}
summary.census <- function(object, numeric_vars = NULL, categorical_vars = NULL) {
 
# Check that the object has the "census" class assigned by query_census()
  if (!("census" %in% class(object))) {
    stop("Object must have class 'census'")
  }
# Check that the weights column exists as it is required for all calculations
  if (!("PWGTP" %in% names(object))) {
    stop("PWGTP (weights) column not found.")
  }
 
  # If user didn't specify which numeric variables to summarize,find all numeric columns except PWGTP (the weight) and YEAR
  if (is.null(numeric_vars)) {
    numeric_vars <- c()
    # Loop through all column names
    for (col_name in names(object)) {
      # Check if column is numeric AND not PWGTP or YEAR
      if (is.numeric(object[[col_name]]) && col_name != "PWGTP" && col_name != "YEAR") {
        numeric_vars <- c(numeric_vars, col_name)
      }
    }
  }
  # If user didn't specify which categorical variables to summarize,
  # find all factor columns (categorical data is stored as factors)
  if (is.null(categorical_vars)) {
    categorical_vars <- c()
    # Loop through all column names
    for (col_name in names(object)) {
      # Check if column is a factor
      if (is.factor(object[[col_name]])) {
        categorical_vars <- c(categorical_vars, col_name)
      }
    }
  }
  # Get the weights vector
  w <- object$PWGTP  
 
  # Create numeric summary with a loop create an empty data frame to store results and add one row for each numeric variable
  numeric_results <- data.frame()
 
   # Loop through each numeric variable
  for (var in numeric_vars) {
    x <- object[[var]]
   
    # Remove NA values
    valid <- !is.na(x) & !is.na(w)
    x_clean <- x[valid]
    w_clean <- w[valid]
   
    # Only calculate if there is data after removing NAs
    if (length(x_clean) > 0) {
      # Calculate weighted mean
      weighted_mean <- sum(x_clean * w_clean) / sum(w_clean)
     
      # Calculate weighted SD
      weighted_sd <- sqrt(sum((x_clean^2) * w_clean) / sum(w_clean) - weighted_mean^2)
     
      # Add row of results to a data frame
      new_row <- data.frame(
        variable = var,
        weighted_mean = weighted_mean,
        weighted_sd = weighted_sd,
        n = length(x_clean),
        weight_sum = sum(w_clean)
      )
     
   # Add the results row above to a results data frame

      numeric_results <- rbind(numeric_results, new_row)
    }
  }
 
  # Create categorical summary with a loop
  categorical_results <- data.frame()
 
  for (var in categorical_vars) {
    f <- object[[var]]
   
    # Remove NA values
    valid <- !is.na(f) & !is.na(w)
    f_clean <- f[valid]
    w_clean <- w[valid]
   
    # Only calculate if there is data after removing NAs
    if (length(f_clean) > 0) {
     
    # droplevels() removes any factor levels that don't appear in the     data
      levels_list <- levels(droplevels(f_clean))
     
      # Calculate weighted sum for each level
      for (lev in levels_list) {
        mask <- f_clean == lev
       
        # Sum weights for this level only
        weighted_n <- sum(w_clean[mask])
       
       # Calculate total weight
        total_weight <- sum(w_clean)
       # Create a data frame with results for this level
        new_row <- data.frame(
          variable = var,
          level = lev,
          weighted_n = weighted_n,
          prop = weighted_n / total_weight
        )
       
        categorical_results <- rbind(categorical_results, new_row)
      }
    }
  }
   # Return a named list with two data frames
  list(numeric = numeric_results, categorical = categorical_results)
}
```

```{r}
summary.census(d2)
```



We created a custom plotting method, `plot.census()`, to visualize Census data with weighted boxplots. The function takes one categorical and one numeric variable, converts them to the right types, and uses survey weights (`PWGTP`) in the plot. A set of descriptive labels replaces variable codes (e.g., `AGEP` → “Age (years)”) to make axes and titles easier to read. This provides a quick way to compare numeric outcomes across demographic groups.



```{r}
library(ggplot2)
plot.census <- function(x, cat_var, num_var, ...) {
  # Ensure categorical variable is treated as a factor
  x[[cat_var]] <- as.factor(x[[cat_var]])
  # Ensure numeric variable is treated as numeric
  x[[num_var]] <- as.numeric(x[[num_var]])
 
  # Descriptive labels
  var_labels <- c(
    "AGEP" = "Age (years)",
    "JWAP" = "Arrival Time at Work (minutes after midnight)",
    "JWDP" = "Departure Time for Work (minutes after midnight)",
    "JWMNP" = "Travel Time to Work (minutes)",
    "GASP" = "Monthly Gas Cost ($)",
    "GRPIP" = "Gross Rent as % of Income",
    "SEX" = "Sex",
    "JWTRNS" = "Mode of Transportation",
    "SCHL" = "Educational Attainment",
    "SCH" = "School Enrollment"
  )
 
  # Look up user-friendly axis labels if available, otherwise use raw variable names
  x_label <- ifelse(cat_var %in% names(var_labels), var_labels[cat_var], cat_var)
  y_label <- ifelse(num_var %in% names(var_labels), var_labels[num_var], num_var)
 
  # Build weighted boxplot using ggplot2
  ggplot(x, aes(x = get(cat_var), y = get(num_var), weight = PWGTP)) +
    geom_boxplot() +
    labs(
      x = x_label,
      y = y_label,
      title = paste(y_label, "by", x_label)
    ) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))  
}

```

```{r}
plot.census(d2, cat_var = "JWTRNS", num_var = "JWAP")
```

